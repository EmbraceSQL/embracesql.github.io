"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9183],{8396:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var n=t(5893),r=t(1151);const a={},i="Catalog Based Generation",o={id:"catalog",title:"Catalog Based Generation",description:"EmbraceSQL generates types for everything in the postgres catalog including:",source:"@site/docs/catalog.md",sourceDirName:".",slug:"/catalog",permalink:"/docs/catalog",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"AutoCRUD",permalink:"/docs/autocrud"},next:{title:"Express",permalink:"/docs/express"}},l={},c=[{value:"Callable Functions &amp; Procedures",id:"callable-functions--procedures",level:2},{value:"Typescript Object / Postgres Table Synchronization",id:"typescript-object--postgres-table-synchronization",level:2},{value:"AutoCRUD",id:"autocrud",level:2}];function d(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h1,{id:"catalog-based-generation",children:"Catalog Based Generation"}),"\n",(0,n.jsx)(s.p,{children:"EmbraceSQL generates types for everything in the postgres catalog including:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"tables"}),"\n",(0,n.jsx)(s.li,{children:"procedures"}),"\n",(0,n.jsx)(s.li,{children:"functions"}),"\n",(0,n.jsx)(s.li,{children:"enums"}),"\n",(0,n.jsx)(s.li,{children:"domains"}),"\n",(0,n.jsx)(s.li,{children:"composite types"}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:["Generated types also have marshalling between the postgres wire protocol\nand typescript. Default types like strings and numbers are easy and handled\nby the ",(0,n.jsx)(s.code,{children:"postgres"})," driver. Composite types, arrays, and nested types are not handled\nby the ",(0,n.jsx)(s.code,{children:"postgres"})," driver, so the catalog metadata is used to generate marshalling."]}),"\n",(0,n.jsxs)(s.p,{children:["The idea is you can use ",(0,n.jsx)(s.em,{children:"any"})," type you can defined in postgres, not just the\nbasic / primitive types, making EmbraceSQL the most full featured way to use\npostgres from typescript."]}),"\n",(0,n.jsx)(s.h2,{id:"callable-functions--procedures",children:"Callable Functions & Procedures"}),"\n",(0,n.jsx)(s.h2,{id:"typescript-object--postgres-table-synchronization",children:"Typescript Object / Postgres Table Synchronization"}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.strong,{children:"Greg's cool feature"})}),"\n",(0,n.jsx)(s.h2,{id:"autocrud",children:"AutoCRUD"}),"\n",(0,n.jsxs)(s.p,{children:["Tables with primary keys qualify for ",(0,n.jsx)(s.a,{href:"/docs/autocrud",children:"AutoCRUD"}),"."]})]})}function p(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);