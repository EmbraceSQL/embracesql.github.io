"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[179],{7670:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>p,frontMatter:()=>c,metadata:()=>d,toc:()=>h});var r=n(5893),a=n(1151);const s='"use client";\n\nimport {\n  EmbraceSQLClient,\n  EmbraceSQLProvider,\n  PgCatalog,\n  Public,\n} from "../../client/dvdrental-react";\nimport { useDebouncedValue, useOnChange } from "@embracesql/react";\nimport React from "react";\n\nfunction Fulltext() {\n  // embrace sql convenience hook to get an event handler\n  // we\'ll use this on an input\n  const { onChange, value } = useOnChange();\n  // and let\'s debounce that to not go crazy\n  const searchString = useDebouncedValue(value);\n\n  // read along the full text index\n  const { rows } = Public.Tables.Film.useFilmFulltextIdx(\n    // and just pass the query through from the input text box\n    {\n      fulltext: searchString ?? "",\n    },\n    {\n      // showing the first page\n      offsetNumberOfRows: 0,\n      limitNumberOfRows: 10,\n      fulltext: {\n        // postgres has multiple parsing options\n        // https://www.postgresql.org/docs/current/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES\n        // we\'ll use the really simple \'web\' style parser\n        queryParser: PgCatalog.Types.Tsvector.FulltextParser.Web,\n      },\n    },\n  );\n\n  if (rows) {\n    // old school - let\'s make a table - EmbraceSQL generates column\n    // name metadata based on the table schemas which makes it easy to iterate\n    return (\n      <div style={{ display: "flex", flexDirection: "column" }}>\n        <input\n          onChange={onChange}\n          style={{ flex: 1 }}\n          placeholder="Enter your search..."\n        />\n        <table>\n          <thead>\n            <tr>\n              {Public.Tables.Film.ColumnNames.map((c) => (\n                <th key={c}>{c}</th>\n              ))}\n            </tr>\n          </thead>\n          <tbody>\n            {rows.map((r) => (\n              <tr key={r.rowNumberInResultset}>\n                {Public.Tables.Film.ColumnNames.map((c) => (\n                  <td key={c}>{`${r[\n                    Public.Tables.Film.Columns[c].fieldName\n                  ]?.toLocaleString()}`}</td>\n                ))}\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  } else {\n    return null;\n  }\n}\n\nexport default function Page() {\n  // connect to where we mounted EmbraceSQL in our server\n  const client = new EmbraceSQLClient({\n    url: `/embracesql`,\n  });\n  // set up the EmbraceSQL context\n  return (\n    <EmbraceSQLProvider client={client}>\n      <Fulltext />\n    </EmbraceSQLProvider>\n  );\n}\n';var l=n(9286),o=n(1430);const c={},i="Full Text Search",d={id:"React/Cookbook/fulltext",title:"Full Text Search",description:"Let's do full text search. In this example the public.film table has a fulltext tsvector NOT NULL",source:"@site/docs/React/Cookbook/fulltext.mdx",sourceDirName:"React/Cookbook",slug:"/React/Cookbook/fulltext",permalink:"/docs/React/Cookbook/fulltext",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Client Retry",permalink:"/docs/React/Cookbook/client_retry"},next:{title:"Database Metadata",permalink:"/docs/React/Cookbook/metadata"}},u={},h=[{value:"Requirements",id:"requirements",level:2},{value:"Steps",id:"steps",level:2},{value:"Generate Code",id:"generate-code",level:3},{value:"Code React",id:"code-react",level:3}];function m(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"full-text-search",children:"Full Text Search"}),"\n",(0,r.jsxs)(t.p,{children:["Let's do full text search. In this example the ",(0,r.jsx)(t.code,{children:"public.film"})," table has a ",(0,r.jsx)(t.code,{children:"fulltext tsvector NOT NULL"}),"\ncolumn maintained by a trigger containing the film title and description."]}),"\n",(0,r.jsx)(t.p,{children:"EmbraceSQL understands tsvector types in indexes, you just pass in the search string."}),"\n",(0,r.jsx)(t.h2,{id:"requirements",children:"Requirements"}),"\n",(0,r.jsxs)(t.p,{children:["Make sure you are read as specified in the ",(0,r.jsx)(t.a,{href:"./",children:"Cookbook"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"steps",children:"Steps"}),"\n",(0,r.jsx)(t.h3,{id:"generate-code",children:"Generate Code"}),"\n",(0,r.jsx)(t.p,{children:"Now that there is a SQL Script - regenerate from the database. If you are already\nrunning NextJS, it'll hot reload."}),"\n",(0,r.jsx)(l.Z,{language:"shell",children:o.Z}),"\n",(0,r.jsx)(t.h3,{id:"code-react",children:"Code React"}),"\n",(0,r.jsx)(t.p,{children:"EmbraceSQL provides a convenient change/state hook to attach to inputs. Lots\nof other approaches are possible here, but this is a one liner."}),"\n",(0,r.jsxs)(t.p,{children:["Hook into the ",(0,r.jsx)(t.code,{children:"public.film"})," table via index. That's it -- full text search\nwith a table result."]}),"\n",(0,r.jsx)(l.Z,{language:"tsx",title:"src/app/by_index/page.tsx",children:s})]})}function p(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},1430:(e,t,n)=>{n.d(t,{Z:()=>r});const r="#!/usr/bin/env bash\n\nmkdir -p src/server\nnpx embracesqlcli generate node --database postgres://postgres:postgres@localhost/dvdrental --sqlScriptsFrom ./sql > ./src/server/dvdrental.ts\n\nmkdir -p src/client\nnpx embracesqlcli generate react --database postgres://postgres:postgres@localhost/dvdrental --sqlScriptsFrom ./sql > ./src/client/dvdrental-react.ts"}}]);